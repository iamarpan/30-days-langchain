import os
from typing import TypedDict, Annotated, List
from langchain_core.messages import BaseMessage, HumanMessage, AIMessage
from langgraph.graph import StateGraph, END
from langgraph.graph.message import add_messages
from dotenv import load_dotenv

load_dotenv()

# --- Simplified Agent State for Multi-Agent Collaboration ---
class MultiAgentState(TypedDict):
    """Represents the shared memory/state for the multi-agent system."""
    
    # Conversation history (could be with a human, or inter-agent messages)
    messages: Annotated[List[BaseMessage], add_messages] 
    
    # Data specific to the report generation
    market_research_data: str # Data gathered by Researcher
    analysis_insights: str    # Insights generated by Analyst
    report_draft: str         # Current draft by Writer
    editor_feedback: str      # Feedback from Editor
    
    # Control flow for the Project Manager
    current_task: str         # e.g., "research", "analyze", "draft", "review"
    report_status: str        # e.g., "in_progress", "awaiting_research", "awaiting_analysis", "awaiting_draft", "awaiting_review", "finalized"

# --- Conceptual Agent Nodes (Simulated Logic) ---

def project_manager_node(state: MultiAgentState) -> MultiAgentState:
    print(f"\n[Project Manager] Current Status: {state['report_status']}")
    # The Project Manager decides the next step based on the report_status
    if state['report_status'] == "start":
        print("[Project Manager] Delegating to Market Researcher.")
        return {"current_task": "research", "report_status": "awaiting_research", "messages": [AIMessage(content="PM: Started market research.")]}
    elif state['report_status'] == "awaiting_research" and state['market_research_data']:
        print("[Project Manager] Research data received. Delegating to Data Analyst.")
        return {"current_task": "analyze", "report_status": "awaiting_analysis", "messages": [AIMessage(content="PM: Research data ready for analysis.")]}
    elif state['report_status'] == "awaiting_analysis" and state['analysis_insights']:
        print("[Project Manager] Analysis insights received. Delegating to Report Writer.")
        return {"current_task": "draft", "report_status": "awaiting_draft", "messages": [AIMessage(content="PM: Analysis ready for drafting report.")]}
    elif state['report_status'] == "awaiting_draft" and state['report_draft']:
        print("[Project Manager] Report draft received. Delegating to Editor.")
        return {"current_task": "review", "report_status": "awaiting_review", "messages": [AIMessage(content="PM: Draft ready for review.")]}
    elif state['report_status'] == "awaiting_review" and state['editor_feedback']:
        # This is where PM decides if revision is needed or finalized
        if "needs revision" in state['editor_feedback'].lower():
            print("[Project Manager] Editor feedback indicates revision. Routing to Report Writer.")
            return {"current_task": "draft", "report_status": "awaiting_draft", "messages": [AIMessage(content=f"PM: Feedback for writer: {state['editor_feedback']}.")]}
        else:
            print("[Project Manager] Report finalized!")
            return {"current_task": "finalize", "report_status": "finalized", "messages": [AIMessage(content="PM: Report finalized!")]}
    
    return state # Should not happen in ideal flow


def market_researcher_node(state: MultiAgentState) -> MultiAgentState:
    print("[Market Researcher] Gathering market data...")
    # In a real scenario, this would involve LLM calls, tool use (e.g., web search)
    dummy_data = "Key market size: $10B, trends: rapid growth in AI sector, main competitors: X, Y, Z."
    return {"market_research_data": dummy_data, "report_status": "awaiting_research", "messages": [AIMessage(content="Researcher: Market data gathered.")]}

def data_analyst_node(state: MultiAgentState) -> MultiAgentState:
    print("[Data Analyst] Analyzing market data...")
    # In a real scenario, this would involve LLM analysis of raw data
    dummy_insights = f"Based on research: Market opportunity is high. Competitors X and Y focus on enterprise. QuantumConnect could target individual developers initially. Data: {state['market_research_data']}"
    return {"analysis_insights": dummy_insights, "report_status": "awaiting_analysis", "messages": [AIMessage(content="Analyst: Analysis complete.")]}

def report_writer_node(state: MultiAgentState) -> MultiAgentState:
    print("[Report Writer] Drafting report sections...")
    # In a real scenario, this would involve LLM synthesizing data into prose
    dummy_report = f"Executive Summary: QuantumConnect enters a growing $10B market. Analysis: {state['analysis_insights']}. Drafted on: {state.get('editor_feedback', 'No feedback yet.')}"
    return {"report_draft": dummy_report, "report_status": "awaiting_draft", "messages": [AIMessage(content="Writer: First draft complete.")]}

def editor_node(state: MultiAgentState) -> MultiAgentState:
    print("[Editor] Reviewing report draft...")
    # In a real scenario, this would involve LLM review/critique
    if "QuantumConnect could target" in state['report_draft']:
        feedback = "Looks good, but needs more detail on market challenges."
    else:
        feedback = "Great draft! Ready for finalization."
    return {"editor_feedback": feedback, "report_status": "awaiting_review", "messages": [AIMessage(content=f"Editor: Provided feedback: {feedback}.")]}


# --- LangGraph Setup ---
print("--- Building the Conceptual Multi-Agent Graph ---")
workflow = StateGraph(MultiAgentState)

# Add agent nodes
workflow.add_node("project_manager", project_manager_node)
workflow.add_node("market_researcher", market_researcher_node)
workflow.add_node("data_analyst", data_analyst_node)
workflow.add_node("report_writer", report_writer_node)
workflow.add_node("editor", editor_node)

# Set the entry point
workflow.set_entry_point("project_manager")

# Define conditional routing from the Project Manager
def route_project_manager(state: MultiAgentState) -> str:
    if state['current_task'] == "research":
        return "market_researcher"
    elif state['current_task'] == "analyze":
        return "data_analyst"
    elif state['current_task'] == "draft":
        return "report_writer"
    elif state['current_task'] == "review":
        return "editor"
    elif state['current_task'] == "finalize":
        return END # Project finished
    return "project_manager" # Loop back for PM to re-evaluate or if no task set yet


workflow.add_conditional_edges(
    "project_manager",
    route_project_manager,
    {
        "market_researcher": "market_researcher",
        "data_analyst": "data_analyst",
        "report_writer": "report_writer",
        "editor": "editor",
        END: END
    }
)

# Define edges from other agents back to the Project Manager for delegation
workflow.add_edge("market_researcher", "project_manager")
workflow.add_edge("data_analyst", "project_manager")
workflow.add_edge("report_writer", "project_manager")
workflow.add_edge("editor", "project_manager") # Editor sends feedback back to PM

# Compile the graph
conceptual_multi_agent_app = workflow.compile()
print("Conceptual Multi-Agent graph compiled successfully.\n")

# --- Invoke the Conceptual System ---
print("--- Invoking the Conceptual Multi-Agent System ---")

initial_state = {
    "messages": [HumanMessage(content="Generate a market research report for QuantumConnect.")],
    "market_research_data": "",
    "analysis_insights": "",
    "report_draft": "",
    "editor_feedback": "",
    "current_task": "start",
    "report_status": "start"
}

try:
    final_state = conceptual_multi_agent_app.invoke(
        initial_state,
        config={"recursion_limit": 50}, # Set a recursion limit for safety
        # verbose=True # Uncomment for verbose LangGraph internal logs
    )
    print("\n--- Final Conceptual State ---")
    print(f"Report Status: {final_state['report_status']}")
    print(f"Final Report Draft (Excerpt): {final_state['report_draft'][:150]}...")
    print(f"Messages Log (Last 3): {final_state['messages'][-3:]}")

except Exception as e:
    print(f"!!! Conceptual agent encountered an unexpected error: {e} !!!")

print("\nNote: This is a conceptual example. In a real system, agent nodes would involve LLM calls, tool invocations, and more sophisticated logic for data processing and communication.")
